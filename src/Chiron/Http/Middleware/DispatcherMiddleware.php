<?php

declare(strict_types=1);

// TODO : regarder ici : https://github.com/zendframework/zend-expressive-router/blob/master/src/Middleware/DispatchMiddleware.php

// TODO : regarder ici https://github.com/zrecore/Spark/blob/master/src/Handler/RouteHandler.php    et https://github.com/equip/framework/blob/master/src/Handler/DispatchHandler.php

// TODO : regarder ici pour l'injection de middlewares : https://github.com/swoft-cloud/swoft-framework/blob/v0.2.6/src/Middleware/Http/UserMiddleware.php#L58

namespace Chiron\Http\Middleware;

use Chiron\Handler\Stack\Decorator\CallableMiddlewareDecorator;
use Chiron\Handler\Stack\Decorator\LazyLoadingMiddleware;
use Chiron\Handler\Stack\RequestHandlerStack;
use Chiron\Routing\Route;
use Chiron\Routing\RouteGroup;
use Chiron\Routing\RouteResult;
use InvalidArgumentException;
use Psr\Container\ContainerInterface;
use Psr\Http\Message\ResponseInterface;
use Psr\Http\Message\ServerRequestInterface;
use Psr\Http\Server\MiddlewareInterface;
use Psr\Http\Server\RequestHandlerInterface;

class DispatcherMiddleware implements MiddlewareInterface
{
    /**
     * Dependency injection container.
     *
     * @var ContainerInterface
     */
    private $container;

    public function __construct(ContainerInterface $container = null)
    {
        $this->container = $container;
    }

    /**
     * Process a server request and return a response.
     */
    public function process(ServerRequestInterface $request, RequestHandlerInterface $handler): ResponseInterface
    {
        // TODO : virer le "false" qui ne sert à rien.
        $routeResult = $request->getAttribute(RouteResult::class);

        // if the route is not a failure, return the response generated by the route handler.
        if ($routeResult && ! $routeResult->isFailure()) {
            $route = $routeResult->getMatchedRoute();
            $routeHandler = $this->createRouteHandler($route);

            return $routeHandler->handle($request);
        }
        // else, return the default response (it's an HTTP 204 empty response).
        return $handler->handle($request);
    }

    private function createRouteHandler(Route $route): RequestHandlerInterface
    {
        $handler = $route->getHandler();
        $middlewares = $route->getMiddlewares();

        $routeGroup = $route->getExtra(RouteGroup::class);
        if ($routeGroup) {
            $groupMiddlewares = $routeGroup->getMiddlewares();
            $middlewares = array_merge($middlewares, $groupMiddlewares);
        }

        if (! empty($middlewares)) {
            $handler = new RequestHandlerStack($handler);
            foreach ($middlewares as $middleware) {
                $handler->prepend($this->prepareMiddleware($middleware));
            }
        }

        return $handler;
    }

    /**
     * Decorate the middleware if necessary.
     *
     * @param string|callable|MiddlewareInterface $middleware
     *
     * @return MiddlewareInterface
     */
    // TODO : code à factoriser avec celui présent dans le Application.php
    private function prepareMiddleware($middleware): MiddlewareInterface
    {
        if ($middleware instanceof MiddlewareInterface) {
            return $middleware;
        } elseif (is_callable($middleware)) {
            return new CallableMiddlewareDecorator($middleware);
        } elseif (is_string($middleware) && $middleware !== '') { // TODO : vérifier l'utilité du chaine vide !!!!
            return new LazyLoadingMiddleware($middleware, $this->container);
        } else {
            throw new InvalidArgumentException(sprintf(
                'Middleware "%s" is neither a string service name, a PHP callable, or a %s instance',
                is_object($middleware) ? get_class($middleware) : gettype($middleware),
                MiddlewareInterface::class
            ));
        }
    }
}
